---
layout: post
title: Python | 기본개념정리
description: >
  "Life is too short, You need Python!" <br> <u>문과생도,비전공자도,누구나 배울 수 있는 파이썬</u> 강의를 수강하고 정리한 내용입니다.
sitemap: true
categories:
  - development
  - python 
tags: python
excerpt_separator: <!--more-->
hide_last_modified: true
---
* toc
{:toc .large-only}
<!--more-->

## 파이썬이란 무엇인가?

파이썬은 대표적인 인터프리터 언어이다. 인터프리터 언어란 소스 코드를 한 줄씩 해석한 후 그때그때 실행해 결과를 바로 확인할 수 있는 언어를 말한다. 또한 파이썬은 인간친화적인 언어다. 컴퓨터의 사고체계에 맞추어 프로그래밍하려고 애쓰지 않아도 어떤 프로그램을 구상하여 직관적으로 코드로 표현할 수 있다. 또한 문법자체가 쉽기 때문에, 프로그래밍 경험이 조금이라도 있다면 파이썬의 자료형, 함수, 클래스 만드는 법, 라이브러리 및 내장 함수등의 사용방법을 익히는데 일주일이면 충분하다.

또한 파이썬으로 할 수 있는 일은 매우 많다. 인공지능분야의 발전과 함께 파이썬도 인기 언어로 떠오른 것을 보면 알 수 있듯이 파이썬은 인공지능과 머신러닝에 사용되는 대표적인 언어로 `사이킷런`,`텐서플로`, `파이토치`, `케라스` 등과 같은 다양한 라이브러리르 제공한다. 특히 데이터 분석의 경우, `넘파이`,`판다스`,`맷플로립`등과 같은 라이브러리등을 활용하여 데이터 처리, 통계 분석, 시각화를 손쉽게 수행할 수 있다. 데이터 분석을 할 때 아직까지는 데이터 분석에 특화된 R을 많이 사용하지만 판다슥 ㅏ등장한 이래 파이썬을 사용하는 경우가 점점 많아지고 있다. 그렇다면 일주일만에 익힐 수 있다는 파이썬의 문법을 가볍게 알아보도록 하자. 



## 파이썬 프로그래밍의 자료형

### 숫자형(Integer, Float)

파이썬의 숫자형은 단순하게 2가지 정수형(Integer)와 실수형(Float)으로 나뉜다. 편리하게도 변수에 할당하는 과정에서 데이터 타입을 명명할 필요 없이, 변수에 해당하는 숫자형을 할당하면 파이썬이 자동으로 타입을 매칭한다. <u>즉, 변수를 할당할 때 변수형을 신경쓰지 않아도 된다는 엄청난 이점이 있다.</u> 물론 직접 데이터 타입을 명시하는 타 프로그래밍 언어들에 비해 파이썬이 직접 데이터타입을 판별하여 할당하므로 속도가 느릴 수 있다. 

### 리스트(list)

동일한 속성의 일련의 데이터를 관리하기 위해 나온 개념. 리스트에 속해있는 각 데이터는 엘리먼트라고 표현한다.

```python
list_a = [1,2,3,4,5]
list_b = list([80,90,100])	#다른 자료형에서 변형하는 형태로 사용하고 싶을 경우 이런 형태로 선언하기도 함
list_c = [1,2,3,[4,5]]	#리스트의 엘리먼트로 리스트를 가질 수 있다
```

#### 리스트의 인덱싱(indexing)

리스트의 가장 큰 특징이라고 할 수 있다. 파이썬은 각 숫자를 0부터 세기 때문에 리스트의 가장 첫 속성을 가져오고 싶을 때는 a[0]의 형태 마지막 속성을 가져오고 싶을 때는 리스트의 엘리먼트가 n개라고 가정했을 때, a[n-1], 혹은 a[-1]로 선언하여 가져온다. 파이썬의 편리함이 돋보이는 부분은 리스트 내의 리스트의 인덱싱이다. 위 예시의 list_c를 보자

```python
list_c[-1] #[4,5] / 마지막 요소인 리스트[4,5]가 출력 됨.
list_c[-1][0] #4  / 리스트 안의 인덱싱을 가져올 수 있다. [4,5]의 첫번째 요소인 4 출력
```

#### 리스트의 슬라이싱(Slicing)

슬라이싱을 사용할 때 [a:b]의 표현범위에 주의하자. **요소 a부터(포함) b까지(미포함)**

```python
list_a[0:2] #[1,2] / 첫번째 요소부터 두번째 요소까지, 0이상 2미만 
list_a[:2] #[1,2] / 리스트의 첫번째 요소부터 세번째 전까지
list_a[2:] #[3,4,5] / 리스트의 3번째 요소부터 끝까지 
```

#### 다차원 리스트

파이썬은 다차원 리스트를 통해 손쉽게 행렬의 형태도 만들 수 있고, 인덱싱과 슬라이싱은 위에 기술한 방법 그대로 적용된다.

```python
[
    [1, 2, 4],
    [1, 2, 3],
    [1, 3, [1, 2]]
]
```

### 튜플(Tuple)

튜플은 **데이터를 []이 아닌 ()로 둘러싼다**는 점, 그리고 **요솟값을 바꿀 수 없는 점(immutable)**을 제외하면 리스트와 동일하다. 

`이러한 튜플은 왜 필요한걸까?` immutable이라는 키워드를 보면 알 수 있듯이 결과적으로 <u>튜플은 리스트와 비교하여 메모리 용량을 아낄 수 있고, 퍼포먼스를 향상시키는데 도움이 된다.</u> 파이썬의 리스트는 다른 언어의 자료구조 중 배열(array)와 연결 리스트(linked list)의 기능을 합한 것 과 유사하다. 즉 그만큼 무겁다. 

익히 알고있듯이, 배열은 선언할 때 그 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간만을 할당받으므로 한 번 생성한 배열의 크기는 변경이 불가능하다. 그렇기에 타 언어에서는 크기 변경이 가능한 list등의 동적 베열 타입을 별도로 제공하고 있다. 다만 파이썬은 리스트가 배열의 속성을 띄면서도 가변가능 객체이기 때문에 메모리를 추가로 할당받을 수 있게 되고 그만큼 오버헤드가 커진다.

이러한 이유로 <span style="color:red">값이 고정되어 있거나, 비교적 작은 크기의 공간을 필요로 하는 데이터를 쓰는 경우에는 리스트보다 튜플을 쓰는 것이 퍼포먼스를 높이는데 도움이 되는 것</span>이다.

### 문자열(string)

파이썬에서 따옴표로 감싸진 형태의 데이터는 모두 문자열이라고 생각하면 된다. 문자열을 표현하는 방법엔 총 4가지가 있다.

```python
"Hello world" 
'Hello world'
"""Hello world"""
'''Hello world'''
```

문장 내부에 " 또는 ' 가 포함되도록 하고 싶은 경우가 있을 것이다. 이럴 때 각각의 방법을 쓰게 되는데 예를 들어 문장 내부에 ' 가 포함되어야 한다면 전체를 " 로 감싸고, " 가 포함되어야 한다면 `로 전체문장을 감싸는 식이다. (이 방법이 번거롭다면 포함하고자 하는 따옴표 앞에 \ 를 사용해주어도 된다.)

연속된 3개의 따옴표를 쓰는 건 언제일까? 바로 문장내에 줄바꿈이 있는 경우이다. <br>큰 따옴표 세 개를 쓰지 않고 문장내 줄바꿈이 필요한 경우 \n을 사용해주는 식으로도 표현이 가능하지만 큰따옴표 세 개를 써주는 방식이 보다 직관적이다.

### 딕셔너리(Dictionary)

key,value 형태의 대응 관계를 가진 한 쌍을 데이터 저장이 가능한 자료형. 자바의 해시 개념에 대응하는 느낌으로 이해한다.<br>딕셔너리는 리스트나 튜플처럼 순차적으로 해당 요소값을 구하지 않고 Key를 통해 Value를 얻는다. key, value의 자료형은 섞여서 사용가능.

```python
# 첫번째 방법
my_dict = {
    123: 456,
    "my_key": 1000
}
# 두번째 방법 
# 단, 두번째 방법에서 key는 stirng형만 가능하다 
# 함수형으로 만들어졌기 때문에, 함수의 argument는 항상 string변수에 할당되는 개념을 생각하면 편함
my_dict = dict(my_value1=456, my_key=1000)
```

#### 메모리에 저장되는 방식 

key는 해시 알고리즘을 통해 특정한 해시값으로 변환되어 저장된다. 해시값을 기계어로 나타내면 메모리의 특정주소가 되는 형식으로 RAM에 해당 주소에 value값이 저장된다. 해시로 변환 된 이 key는 아주 높은 확률로 유일성을 보장받기 때문에 원하는 value를 찾고 싶으면 전체를 검색할 필요없이 key값이 있는 주소에 가서 값을 가져오면된다. 

#### 리스트와의 차이 

검색속도에 있어서 딕셔너리가 훨씬 우월한 퍼포먼스를 보인다.

```python
company_price_list = [["삼성전자", 10], ["현대차", 90]]
stock_dict = {"삼성전자": 10, "현대차": 90,}
stock_dict["삼성전자"] #20
stock_dict["하이닉스"] = 100 #딕셔너리에 요소추가
```

### 집합(Set)

집합 자료형 역시 내부적으로 해시 알고리즘을 사용한다. 특징으로는 **중복을 허용하지 않고, 순서가 없다는 점**을 들 수 있다.

```python
a = {1,2,3,1}
a # {1,2,3} / 중복을 허용하지 않기 때문에 출력할 경우 1은 한번만 출력
b = set("Hello")
b # {'e', 'H', 'l', 'o'}
```

이러한 점을 활용하여 리스트로 만들어진 자료형의 중복을 제거하고 싶은 경우 set으로 변환하여 사용하기도하고, 반대로 순서가 없는 set에서 인덱싱을 통한 요소를 얻고 싶을 경우 리스트나 튜플로 변환한 후에 자료를 다룬다. 

```python
my_list = [1,2,3,4,4]
my_set = set(my_list)
my_set #{1,2,3,4}
re_list = list(my_set)
re_list[3] #4 
```

### 불(boolean)

자료형의 참(True)과 거짓(False)를 나타내는 자료형이다. 불 자료형은 다음 2가지 값만 가질 수 있다. (이 때, True, False의 첫 문자는 항상 대문자로 작성하도록 한다.)

```python
True or False #True / or 연산자는 둘 중 하나만 True여도 True를 반환한다.
```

- 자료형으로도 참,거짓을 판별할 수 있는데 파이썬에서는 각 자료형에 대해 '빈값'을 거짓으로 간주하고, 비어있지 않은 값을 참으로 간주한다.
- 파이썬에서 True는 숫자형으로 매핑될 경우 1을 나타내고, False는 0을 나타낸다.

## 함수

반복적으로 사용되는 가치 있는 부분을 한 뭉치로 묶어 입력값에 대한 출력값을 리턴해준다라는 게 함수의 정의라고 할 수 있다. 이러한 함수는 코드의 중복을 줄여주고, 작성한 프로그램을 기능 단위로 분리해놓음으로써 프로그램의 흐름을 일목요연하게 볼 수 있게 하는등의 이점을 제공한다.

### 함수의 정의와 호출

```python
def 함수명(매개변수1, 매개변수2, ...):
	구문1
  구문2
  구문3
  return 출력값
```

#### 매개변수와 인수

매개변수(parameter)와 인수(arguments)를 혼용하지 않고 잘 사용할 수 있도록 하자. 매개변수는 함수에 입력으로 전달 된 값을 받는 변수, 인수는 함수를 호출할 때 전달하는 입력값을 의미한다.

```python
def add(a, b):  #a, b는 매개변수 / 함수정의
    return a+b 
print(add(3, 4))  #3, 4는 인수 / 함수호출
```

#### 함수의 cascading

```python
def get_my_lucky_number():
    return 7
def my_sum(x, y):
    return x + y
my_sum(get_my_lucky_number(), 5) # 함수를 변수에 할당하지 않고 자체로 넣어도 7로 인식됨
my_sum(7, 5)  # 실질적으로 이렇게 호출이 됨 
```

## 클래스

클래스는 어떠한 규약이나 틀을 의미한다. 과자를 만드는 과정을 예로 들었을 때, 계속 똑같은 형태의 과자를 만들어 낼 수 있는 과자 틀을 클래스로 생각하고, 과자 틀로 찍어낸 과자를 클래스에서 만들어진 객체로 생각하면 편하다. 이러한 클래스로 만든 객체에는 각 객체마다 고유한 성격을 가진다는 중요한 특징이 있다. 과자 하나를 먹는다고 모든 과자가 영향을 받지 않는 것 처럼 동일한 클래스로 만들어진 각 객체들은 서로에게 영향을 주지 않는다.

> 💡**객체와 인스턴스**
>
> 클래스로 만든 객체를 `인스턴스`라고도 한다. 이를 코드를 해석하듯이 표현하자면 아래와 같다.<br>`a = Cookie()` 라고 할 때, <u>a객체</u>는 <u>Cookie의 인스턴스</u>라고 표현한다. <br>다시말해 인스턴스는 특정 객체가 어떤 클래스의 객체인지를 관계위주로 설명할 때 사용된다고 생각하면 된다.

클래스의 구조 

- 명사 : attribute, property, instance 변수
- 동사 : method / 클래스 내부에 선언 된 함수

```python
# class 클래스이름:
#    - 명사(attribute)를 초기화 하는 공간 
#    - 동사(behavior)를 정의하는 공간 
```

### 클래스의 정의와 호출

- **동사에 대한 규약 (behavior) / method**

```python
class SoccerPlayer:
  def shoot(self):
    print("슛을 날립니다. 슛!")
	def pass_the_ball(self):
    print("패스를 합니다.")
    
player = SoccerPlayer()
player.shoot() # 슛을 날립니다. 슛!
player.pass_the_ball() # 패스를 합니다.
```

위와 같이 SoccerPlayer 클래스를 선언하고 행동(method)를 정의했다. 

- **명사에 대한 규약 / attribute 초기화 (feat. 생성자)**

```python
class SoccerPlayer:
    def __init__(self):
      print("SoccerPlayer 생성")
    
    def shoot(self):
      print("슛을 날립니다. 슛!")
      
player1 = SoccerPlayer() # SoccerPlayer 생성 / 객체를 player1에 할당만 했지만 바로 __init__메소드가 실행됨
```

`__init__` : 인스턴스를 생성할 때, 생성하는 시점에 호출되는 함수 as **생성자**<br> 클래스의 인스턴스를 생성할 때 자동으로 호출되며, 인스턴스가 생성될 때 초기화 작업을 진행하는 메소드이다. 첫번째 매개변수로 self를 사용하며 self를 통해 인스턴스 변수를 초기화하고, 필요한 경우 다른 초기화 작업을 수행할 수 있다.

cf) init과 같이 앞 뒤로 언더스코어가 있는 경우 이를 던더메소드라고 일컫는다. (Double Underscore Method)

- **self ?**

  파이썬에서 클래스의 인스턴스를 나타내는 변수로 클래스를 정의할 때 메소드의 첫 번째 매개변수로 반드시 사용되어야하는 특별한 변수이다. self를 사용하면 인스턴스 변수와 인스턴스 메소드에 접근할 수 있다. self의 존재이유는 아래의 코드로 자세히 살펴보자.

```python
class SoccerPlayer:
    def __init__(self, height, weight):
        print("SoccerPlayer 생성")
        self.height = height
        self.weight = weight
    
    def shoot(self):
      	self.height = self.height + 1
        print("슛을 때립니다")
        
player1 = SoccerPlayer(height=180, weight=50)
print(player1.height) #180
player1.shoot()
print(player1.height) #181

player2 = SoccerPlayer(height=160, weight=70)
print(player2.height) #160
player2.shoot()
print(player2.height) #161
print(player1.height) #181
```

 가장 마지막 platyer1의 height을 출력한 부분을 확인하면, 값이 변하지 않은 것을 확인할 수 있다. player2의 shoot메서드를 통해 height+1이 실행되었어도 각 메서드의 내부는 self. 으로 시도되었으므로 서로에게 영향을 미치지 않고 각각의 결과값을 따로 저장하고 있는 걸 확인할 수 있는 것이다.

### 클래스의 상속 (Inheritence)

```python
class Human:
    def __init__(self, weight, height):
        self.weight = weight
        self.height = height
    
    def walk(self):
        print("걷습니다")
```

```python
class Athelte:
    def __init__(self, weight, height):
        self.weight = weight
        self.height = height
    
    def walk(self):
        print("걷습니다")
    
    def workout(self):
      print("운동을 합니다")
```

위의 Human클래스와 Athelte클래스를 살펴보면 코드의 중복이 발생한 걸 확인할 수 있다. 본질적으로 생각해봤을 때 운동선수라는 개념은 인간에 종속되고 그렇기에 인간이 할 수 있는 행위를 당연히 할 수 있고 그에 추가적으로 workout이라는 운동선수로서의 차별점이 늘어난 것 뿐인 것이다. 그렇다면 이런 경우, 코드를 그대로 중복해적는 것은 가시성은 물론이고 훗날 유지보수에도 크게 좋지 않은 영향을 미친다. 그렇기에 이러한 공통 된 속성과 기능을 효율적으로 관리할 수 있는 '상속'이라는 개념이 생겨난 것이다.

```python
class Athlete(Human):            
    def workout(self):
        print("운동을 합니다")
```

위와 같이 상속 받을 클래스의 매개변수로 상속 할 클래스를 넘겨주면 간단히 상속을 할 수 있다. 이로써 Athelte는 Human의 기능을 그대로 사용할 수 있게 된다. 그렇다면 꼭 똑같이만 사용해야할까? 운동선수라는 특성 상, 키와 몸무게 이외의 속성을 추가하고 싶을 수도 있고, 걷는다는 메소드에도 무언가 다른 행위를 추가하고 싶을 수도 있을 것이다. 이런 경우를 위해 `오버라이딩`이라는 개념이 생기게 된다.

```python
class Athlete(Human):
    #생성자 오버라이딩(overriding)
    def __init__(self, weight, height, fat_rate):
      	#부모의 생성자를 명시적 호출 / 부모의 생성자 값이 필요없는 경우 호출하지 않아도 된다
        super().__init__(weight, height) 
        self.fat_rate = fat_rate
        
    def workout(self):
        print("운동을 합니다")
```

### 파이썬 기본 자료형(클래스)별 api 

[파이썬/C API 레퍼런스 설명서](https://docs.python.org/ko/3.13/c-api/index.html)

## 제어문 - if/else

```python
if (bool condition):
    구문1
    구문2
    ....
else:
    구문1
    구문2
    ....
    
## 예시
title = "오늘 밤에 비가 올까요?"
if "밤" in title:
    print("밤이 포함된 문장입니다")
else:
    print("밤이 포함되지 않은 문장입니다.")
```

## 반복문 - for

```python
for 임시변수 in 리스트같은 형식의 자료형:
      구문1
      구문2
      ....
## 예시
for tmp_var in range(50, 100, 2):
    print(tmp_var)
## 반복문+제어문
for tmp_var in range(50, 100): 
  if tmp_var%2 == 0:
    print(tmp_var)
```

## 반복문 - while

for와 유사하게 사용되지만, for와 같이 리스트 같은 형식의 자료형이 반드시 필요하지는 않다.

```python
while (비교 연산):
    구문1
    구문2
    ....
```
